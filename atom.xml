<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qzwlecr&#39;s Blog</title>
  <subtitle>一个辣鸡选手的自娱自乐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qzwlecr.github.io/"/>
  <updated>2017-08-07T06:40:43.853Z</updated>
  <id>http://qzwlecr.github.io/</id>
  
  <author>
    <name>qzwlecr</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UniqueStudio 夏令营小结</title>
    <link href="http://qzwlecr.github.io/2017/08/07/UniqueStudio-%E5%A4%8F%E4%BB%A4%E8%90%A5%E5%B0%8F%E7%BB%93/"/>
    <id>http://qzwlecr.github.io/2017/08/07/UniqueStudio-夏令营小结/</id>
    <published>2017-08-07T06:31:23.000Z</published>
    <updated>2017-08-07T06:40:43.853Z</updated>
    
    <content type="html"><![CDATA[<p>小小地总结一下过去的夏令营www假装记录下学的东西</p>
<a id="more"></a>
<h2 id="分布式学习"><a href="#分布式学习" class="headerlink" title="分布式学习"></a>分布式学习</h2><p>本来这个假期是想好好肝分布式的基础内容的，然而并不是那么有动力，时间精力也并没有太花在这上面。简单地说，认真读完了<code>MapReduce</code>、<code>Google File System</code>、<code>Raft</code>、<code>Fault-Tolerant Virtual Machine</code>以及<code>ZooKeeper</code>的论文，并补习了相关的一些基础知识；按照<code>MIT Lab 6.824</code>的要求，做完了<code>Lab 2</code>、<code>Lab 3A</code>，并通过了全部Test。想来的话确实是收获了很多以前没仔细看过、只是了解而已的知识，还自己探究了很多细节上的问题，大概可以说收获了分布式的思想方法吧。</p>
<p>读论文的话没什么问题，按着<code>MIT 6.824 Schedule</code>的<code>Preparation</code>读就是了，不会就查；反倒是<code>Lab</code>耗费了大量的时间，单单一个<code>Lab 2</code>，Debug时间大约在一周左右，感觉写的测试代码比最终代码还要长很多，陷入无限的绝望之中。两个<code>Lab</code>里踩的几个坑大概有：<code>RPC</code>不一定按照发送的时间顺序接收、加锁不注意的话很容易出现<code>race condition</code>、测试使用更大的<code>election timeout</code>会更容易选举成功、向<code>ApplyCh</code>写入时异步会出现顺序错乱、<code>RPC</code>发送结构体必须先注册再发送、<code>interface</code>要随时注意转换的情况。惨惨惨qaq…</p>
<h2 id="镜像源部署"><a href="#镜像源部署" class="headerlink" title="镜像源部署"></a>镜像源部署</h2><p>莫名其妙接了一口锅，好好配置一下以前的脚本保证能用的就好，结果后来基本都是@Recolic重写了一套脚本在搞，我就变成了打杂选手233</p>
<p>首先是<code>rsync</code>同步大文件的问题，加上<code>--size-only</code>参数情况就会好很多，主要是由于大文件的校验和在远端传输有一些缓慢造成的；其次是同步状态的更新问题，本来是学长写的渲染引擎，后来和前端交流了一下改成<code>jinja2</code>，再后来想了想又把它改成了<code>PHP</code>，本地读取文件状态。问题不算太多，还算比较顺利了。</p>
<p>欢迎来玩：<a href="mirrors.hustunique.com">mirrors.hustunique.com</a></p>
<h2 id="C语言课设"><a href="#C语言课设" class="headerlink" title="C语言课设"></a>C语言课设</h2><p>一个超级垃圾的学生作业管理系统，却强行搞了一个前后端分离的架构复习了一下网络通信和多线程，现在只写了一个开头，打算回家之后好好写完，顺便摸一波鱼，没什么难度就不说了。</p>
<h2 id="Hack-Init"><a href="#Hack-Init" class="headerlink" title="Hack.Init()"></a>Hack.Init()</h2><p>中间的时候跑去上海参加了一下<code>Hack.Init()</code>，结识了来自各地的三个小哥，入手了一下<code>Flask</code>和<code>Tensorflow</code>做了一次<code>API Caller</code>，可以说是非常绝望了。我们做了一个智能硬件，用机器学习识别后方汽车和行驶方向，提醒驾驶员防止疲劳驾驶。可是最后因为串口通信和识别函数写炸的问题，并没有拿到奖，不过经历还是蛮开心的。就当去上海旅游了一趟。</p>
<h2 id="Hackweek"><a href="#Hackweek" class="headerlink" title="Hackweek"></a>Hackweek</h2><p>由于某些不可言说的问题，实现了一套支持用户自定义代理认证和细节填充的软件，顺利拿到了内部<code>Hackweek</code>第一名，巨开心www服务端使用<code>Go</code>语言、客户端使用<code>C++</code>进行开发，方便跨平台移植，以后<code>shadow*ocks</code>没有了就靠自己写的了2333</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个多月过的可以说是很充实了，学了也算是不少东西，不过不会的东西还是太多了，和dalao差距有点大，加油加油www</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小小地总结一下过去的夏令营www假装记录下学的东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://qzwlecr.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Google File System：一个面向大规模数据密集型应用的分布式文件系统</title>
    <link href="http://qzwlecr.github.io/2017/07/21/Google-File-System-%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%90%91%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://qzwlecr.github.io/2017/07/21/Google-File-System-一个面向大数据的分布式文件系统/</id>
    <published>2017-07-21T11:41:31.000Z</published>
    <updated>2017-07-22T12:16:18.720Z</updated>
    
    <content type="html"><![CDATA[<p>Google File System是一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。虽然它运行在廉价的硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。</p>
<p>在了解完MapReduce的相关内容后，我阅读了GFS的论文，产生了一些自己的思考，在这里记录下来。</p>
<a id="more"></a>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul>
<li>组件崩溃被视为常态事件，而非意外事件。</li>
<li>存储的文件非常巨大。</li>
<li>绝大部分修改采用Append，而非Overwrite。</li>
<li>主要包括大规模的顺序读取和小规模的随机读取。</li>
<li>需要支持高效的原子性的并发操作，提供create（创建）、delete（删除）、open（打开）、close（关闭）、read（读取）、write（写入）、record append（记录追加）、snapshot（快照）操作。</li>
</ul>
<h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p><img src="/images/GFS/1.png" alt="设计架构"></p>
<p>GFS的架构由一个Master节点和多台Chunk服务器构成，并有若干Client与其交互。</p>
<h3 id="特点概述"><a href="#特点概述" class="headerlink" title="特点概述"></a>特点概述</h3><ul>
<li>文件分块（Chunk）。为了减少Client和Master的交互，减少网络压力，减小Metadata的大小，GFS中的Chunk为64MB，每块有一个唯一的64位标识符，由Master为Chunk在创建时分配，缺省状态下，每个Chunk被存储在三个机器上。</li>
<li>元数据（Metadata）管理。由Master对命名空间、访问控制信息、文件和Chunk的映射关系、Chunk的存储位置进行管理米，通常情况下，Metadata存储于内存中（实际大小很小）。</li>
<li>活动管理。由Master对Chunk租约（Lease）、Chunk迁移、孤儿Chunk的回收等进行管理，Master定期向Chunk服务器发送Heartbeat，更新相关信息。</li>
<li>直接通信。Client与单一Master进行通信，获取元数据，之后直接与Chunk服务器进行通信，执行读写操作。</li>
<li>不缓存数据。由于系统的特点，Client和Chunk服务器都不会对所存储的数据进行缓存，从而简化了设计。</li>
<li>操作日志。操作日志包含了Metadata变更的历史记录，它表示了并发操作的逻辑时间线，可以和定期持久化到硬盘的Checkpoint一起被用做Master的灾难恢复。</li>
<li>一致性保障。GFS实现了较为宽松的一致性保障机制，Master对命名空间的修改具有原子性，在串行成功操作时，写入和追加操作都是已定义的（一致并且客户端完全知晓所有的操作）；在并行成功操作时，写入是一致却未定义的，追加操作是部分不一致的；在错误操作时，写入和追加操作都是不一致的。</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h2 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h2><ul>
<li>未完待续……</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google File System是一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。虽然它运行在廉价的硬件设备上，但是它依然了提供灾难冗余的能力，为大量客户机提供了高性能的服务。&lt;/p&gt;
&lt;p&gt;在了解完MapReduce的相关内容后，我阅读了GFS的论文，产生了一些自己的思考，在这里记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://qzwlecr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Raft：一种易于理解的一致性算法 &amp;&amp; MIT 6.824 Lab 2</title>
    <link href="http://qzwlecr.github.io/2017/07/19/Raft-%E4%B8%80%E7%A7%8D%E6%98%93%E4%BA%8E%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95-MIT-6-824-Lab-2/"/>
    <id>http://qzwlecr.github.io/2017/07/19/Raft-一种易于理解的一致性算法-MIT-6-824-Lab-2/</id>
    <published>2017-07-19T13:17:03.000Z</published>
    <updated>2017-07-19T14:47:06.927Z</updated>
    
    <content type="html"><![CDATA[<p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制
    
    </summary>
    
    
      <category term="分布式" scheme="http://qzwlecr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Lab" scheme="http://qzwlecr.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce：大规模集群上的简单数据处理方式 &amp;&amp; MIT 6.824 Lab 1</title>
    <link href="http://qzwlecr.github.io/2017/06/12/MapReduce-%E5%A4%A7%E8%A7%84%E6%A8%A1%E9%9B%86%E7%BE%A4%E4%B8%8A%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-MIT-6.824-Lab-1/"/>
    <id>http://qzwlecr.github.io/2017/06/12/MapReduce-大规模集群上的简单数据处理方式-MIT-6.824-Lab-1/</id>
    <published>2017-06-12T03:36:28.000Z</published>
    <updated>2017-07-20T05:15:04.180Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce是Google公司的Jeffrey和Sanjay提出的一个编程模型，主要用于大规模数据集的并行运算。它吸收了函数式编程语言中的Map和Reduce，通过Map处理原始键值对生成中间键值对，通过Reduce合并相同中间键对应的值。这一特性符合很多现实生活中的场景。</p>
<p>这种编程模型下的程序可以并行化地在大规模集群上运行，而在这一过程中用户却不需考虑输入数据的划分、程序的运行安排、节点故障和机器间通信，只需完成对数据的处理和合并。</p>
<p>我阅读了MapReduce的论文，并完成了MIT 6.824的第一个Lab，对其有了更深的了解。</p>
<a id="more"></a>
<h2 id="过程总览"><a href="#过程总览" class="headerlink" title="过程总览"></a>过程总览</h2><p><img src="/images/Map-Reduce/overview.png" alt="overview"></p>
<ol>
<li>用户程序调用MapReduce库，先把输入文件划分为M份（M可由用户指定），每一份通常为16MB到64MB，如图左方所示分成了split0~4，然后将用户程序fork到集群内其它机器上。 </li>
<li>用户程序副本中有一个称为master，其余称为worker，master负责调度，为空闲worker分配任务（Map任务或者Reduce任务）。 </li>
<li>Map worker开始读取对应的输入数据，它们从输入数据中抽取出Key-Value Pair，每一个都作为参数传递给Map函数，Map函数产生的中间Key-Value Pair被缓存在内存中。 </li>
<li>缓存在内存中的中间Key-Value Pair会被定期写入本地磁盘，而且被分为R个区（R可由用户指定），这些中间Key-Value Pair的位置会被通报给master，master负责将信息通报给Reduce worker。 </li>
<li>master通报Reduce worker它负责的分区的位置，当Reduce worker把所有它负责的中间数据都读过来后，先对它们进行排序，使得相同Key的数据聚集在一起。若内部排序无法满足要求，则使用外部排序。</li>
<li>Reduce worker遍历排序后的中间Key-Value Pair，对于每个唯一的Key，都将Key与关联的Value传递给Reduce函数，Reduce函数产生的输出会添加到对应分区的输出文件中。</li>
<li>当所有的Map和Reduce作业都完成了，master唤醒用户程序，MapReduce函数返回。</li>
<li>MapReduce共产生R个输出文件（对应R个Reduce任务），用作分布式存储系统或其他分布式应用中。</li>
</ol>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h3 id="Worker错误"><a href="#Worker错误" class="headerlink" title="Worker错误"></a>Worker错误</h3><p>当master定期发送的ping在某一时间段内没有到达某worker时，将该worker置为失效：</p>
<ol>
<li>若该worker任务为Map，则将该worker的所有任务置为空闲，并在分配任务时将其安排给其他的worker；当一个接替其任务的Map worker完成时，向所有Reduce worker发送通知，任何还未从失效worker读取数据的Reduce worker将从新worker读取数据；</li>
<li>若该worker任务为Reduce，则将该worker的正在运行的任务置为空闲，并在分配任务时将其安排给其他的worker；已完成的任务不做调整。</li>
</ol>
<h3 id="Master错误"><a href="#Master错误" class="headerlink" title="Master错误"></a>Master错误</h3><p>由于只有一个master，因此在发生错误时会返回主程序，由客户端确认状态。</p>
<h3 id="容错性保证"><a href="#容错性保证" class="headerlink" title="容错性保证"></a>容错性保证</h3><p>当用户提供的Map和Reduce操作对输入为确定函数时，分布式实现的输出与顺序输出保持一致，这种一致性是通过对Map和Reduce操作的输出进行原子提交来保证的，即依赖于文件系统的原子性操作。</p>
<p>当用户提供的Map和Reduce操作对输入为不确定函数时，最终输出本就不确定，也可以一定程度上保证一致性。</p>
<h2 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h2><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>利用GFS，对数据产生多个备份，在调用任务时，尽量从本地读取数据，避免网络调用占用带宽，降低速度。</p>
<h3 id="片段分配"><a href="#片段分配" class="headerlink" title="片段分配"></a>片段分配</h3><p>为了保证速度和准确性，需要有效分配片段，通常限制M，使每一份为16MB到64MB，而R为worker机器数量的小倍数。</p>
<h3 id="备用任务"><a href="#备用任务" class="headerlink" title="备用任务"></a>备用任务</h3><p>当一个MapReduce将要完成的时候，master启用备用进程，来执行还在执行的任务，以减少落后worker造成的影响。</p>
<h2 id="Lab-解析"><a href="#Lab-解析" class="headerlink" title="Lab 解析"></a>Lab 解析</h2><p>本Lab要求你补全一个基本完成的MapReduce程序，共有5个Part，其中Part I、II为Sequential MapReduce，Part III、IV为Sequential MapReduce，Part V为附加任务。程序整体难度不大，主要的难点在于熟悉Go语言。</p>
<h3 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h3><p>要求实现两个模板化的函数<code>doMap</code>和<code>doReduce</code>，按照注释所给步骤以及论文相关步骤编写即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></div><div class="line">   jobName <span class="keyword">string</span>, </div><div class="line">   mapTaskNumber <span class="keyword">int</span>, </div><div class="line">   inFile <span class="keyword">string</span>,</div><div class="line">   nReduce <span class="keyword">int</span>, </div><div class="line">   mapF <span class="keyword">func</span>(file <span class="keyword">string</span>, contents <span class="keyword">string</span>) []<span class="title">KeyValue</span>,</div><div class="line">) &#123;</div><div class="line">   inContent, err := ioutil.ReadFile(inFile)</div><div class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">      fmt.Fprintln(os.Stderr, err)</div><div class="line">      <span class="keyword">return</span></div><div class="line">   &#125;</div><div class="line">   keyValue := mapF(inFile, <span class="keyword">string</span>(inContent))</div><div class="line">   partitions := <span class="built_in">make</span>([]*json.Encoder, nReduce, nReduce)</div><div class="line">   <span class="keyword">for</span> id := <span class="number">0</span>; id &lt; nReduce; id++ &#123;</div><div class="line">      handler, err := os.OpenFile(reduceName(jobName, mapTaskNumber, id), os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</div><div class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">         fmt.Fprintln(os.Stderr, err)</div><div class="line">         <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">defer</span> handler.Close()</div><div class="line">      partitions[id] = json.NewEncoder(handler)</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> _, keyValueSingle := <span class="keyword">range</span> keyValue &#123;</div><div class="line">      _ = partitions[ihash(keyValueSingle.Key)%nReduce].Encode(&amp;keyValueSingle)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></div><div class="line">   jobName <span class="keyword">string</span>, </div><div class="line">   reduceTaskNumber <span class="keyword">int</span>, </div><div class="line">   outFile <span class="keyword">string</span>, </div><div class="line">   nMap <span class="keyword">int</span>, </div><div class="line">   reduceF <span class="keyword">func</span>(key <span class="keyword">string</span>, values []<span class="keyword">string</span>) <span class="title">string</span>,</div><div class="line">) &#123;</div><div class="line">   midContentBuf := bytes.NewBuffer(<span class="literal">nil</span>)</div><div class="line">   <span class="keyword">for</span> maps := <span class="number">0</span>; maps &lt; nMap; maps++ &#123;</div><div class="line">      f, err := os.Open(reduceName(jobName, maps, reduceTaskNumber))</div><div class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">         fmt.Fprintln(os.Stderr, err)</div><div class="line">         <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      io.Copy(midContentBuf, f)</div><div class="line">      f.Close()</div><div class="line">   &#125;</div><div class="line">   decoder := json.NewDecoder(bytes.NewReader(midContentBuf.Bytes()))</div><div class="line">   <span class="keyword">var</span> kv KeyValue</div><div class="line">   keyValueMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</div><div class="line">   <span class="keyword">for</span> &#123;</div><div class="line">      err := decoder.Decode(&amp;kv)</div><div class="line">      <span class="keyword">if</span> err == io.EOF &#123;</div><div class="line">         <span class="keyword">break</span></div><div class="line">      &#125;</div><div class="line">      keyValueMap[kv.Key] = <span class="built_in">append</span>(keyValueMap[kv.Key], kv.Value)</div><div class="line">   &#125;</div><div class="line">   keys := []<span class="keyword">string</span>&#123;&#125;</div><div class="line">   <span class="keyword">for</span> keyValueSingle := <span class="keyword">range</span> keyValueMap &#123;</div><div class="line">      keys = <span class="built_in">append</span>(keys, keyValueSingle)</div><div class="line">   &#125;</div><div class="line">   sort.Strings(keys)</div><div class="line">   answerFileName := mergeName(jobName, reduceTaskNumber)</div><div class="line">   answerFile, err := os.OpenFile(answerFileName, os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</div><div class="line">   <span class="keyword">defer</span> answerFile.Close()</div><div class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">      fmt.Fprintln(os.Stderr, err)</div><div class="line">      <span class="keyword">return</span></div><div class="line">   &#125;</div><div class="line">   encoder := json.NewEncoder(answerFile)</div><div class="line">   <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</div><div class="line">      encoder.Encode(KeyValue&#123;key, reduceF(key, keyValueMap[key])&#125;)</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h3><p>要求实现wordcount，闭着眼睛乱写可以通过测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</div><div class="line">   keyValues := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">      <span class="keyword">return</span> !unicode.IsLetter(c)</div><div class="line">   &#125;</div><div class="line">   fields := strings.FieldsFunc(contents, f)</div><div class="line">   <span class="keyword">for</span> _, each := <span class="keyword">range</span> fields &#123;</div><div class="line">      keyValues = <span class="built_in">append</span>(keyValues, mapreduce.KeyValue&#123;each, <span class="string">""</span>&#125;)</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> keyValues</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">   <span class="keyword">return</span> strconv.Itoa(<span class="built_in">len</span>(values))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Part-III-Distributing-MapReduce-tasks"><a href="#Part-III-Distributing-MapReduce-tasks" class="headerlink" title="Part III: Distributing MapReduce tasks"></a>Part III: Distributing MapReduce tasks</h3><p>要求实现给worker分配任务的<code>schedule</code>函数，worker地址是通过<code>registerChannel</code>获取的，在<code>schedule</code>中会启动n个<code>goroutine</code>，每个都从<code>registerChannel</code>中获取worker地址，然后进行<code>RPC</code>调用，成功后，再放回到<code>registerChannel</code>中。这里首次使用了<code>channel</code>和<code>goroutine</code>等Go语言的高级特性，需要好好学习。</p>
<h3 id="Part-IV-Handling-worker-failures"><a href="#Part-IV-Handling-worker-failures" class="headerlink" title="Part IV: Handling worker failures"></a>Part IV: Handling worker failures</h3><p>在Part 3的基础上，要求实现worker的容错机制，这里只需要简单地不把无法到达的worker加入<code>registerChannel</code>中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">   <span class="keyword">var</span> ntasks <span class="keyword">int</span></div><div class="line">   <span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></div><div class="line">   <span class="keyword">switch</span> phase &#123;</div><div class="line">   <span class="keyword">case</span> mapPhase:</div><div class="line">      ntasks = <span class="built_in">len</span>(mapFiles)</div><div class="line">      n_other = nReduce</div><div class="line">   <span class="keyword">case</span> reducePhase:</div><div class="line">      ntasks = nReduce</div><div class="line">      n_other = <span class="built_in">len</span>(mapFiles)</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</div><div class="line"></div><div class="line">   <span class="keyword">var</span> waitGroup sync.WaitGroup</div><div class="line">   <span class="keyword">for</span> task := <span class="number">0</span>; task &lt; ntasks; task++ &#123;</div><div class="line">      waitGroup.Add(<span class="number">1</span>)</div><div class="line">      worker := &lt;-registerChan</div><div class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, worker <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">         <span class="keyword">defer</span> waitGroup.Done()</div><div class="line">         args := DoTaskArgs&#123;jobName, mapFiles[id], phase, id, n_other&#125;</div><div class="line">         ok := call(worker, <span class="string">"Worker.DoTask"</span>, args, <span class="literal">nil</span>)</div><div class="line">         <span class="keyword">if</span> !ok &#123;</div><div class="line">            <span class="keyword">for</span> !ok &#123;</div><div class="line">               worker := &lt;-registerChan</div><div class="line">               ok = call(worker, <span class="string">"Worker.DoTask"</span>, args, <span class="literal">nil</span>)</div><div class="line">               <span class="keyword">if</span> ok &#123;</div><div class="line">                  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">                     registerChan &lt;- worker</div><div class="line">                  &#125;()</div><div class="line">                  <span class="keyword">break</span></div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">               registerChan &lt;- worker</div><div class="line">            &#125;()</div><div class="line">         &#125;</div><div class="line">      &#125;(task, worker)</div><div class="line">   &#125;</div><div class="line">   waitGroup.Wait()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Part-V-Inverted-index-generation-optional-for-extra-credit"><a href="#Part-V-Inverted-index-generation-optional-for-extra-credit" class="headerlink" title="Part V: Inverted index generation (optional for extra credit)"></a>Part V: Inverted index generation (optional for extra credit)</h3><p>要求实现一个倒排索引，难度不大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</div><div class="line">   keyValues := <span class="built_in">make</span>([]mapreduce.KeyValue, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">   f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</div><div class="line">      <span class="keyword">return</span> !unicode.IsLetter(c)</div><div class="line">   &#125;</div><div class="line">   fields := strings.FieldsFunc(value, f)</div><div class="line">   sort.Strings(fields)</div><div class="line">   <span class="keyword">for</span> _, each := <span class="keyword">range</span> fields &#123;</div><div class="line">      keyValues = <span class="built_in">append</span>(keyValues, mapreduce.KeyValue&#123;each, document&#125;)</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> keyValues</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">   uniq := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">   <span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</div><div class="line">      uniq[value] = <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   answer := strconv.Itoa(<span class="built_in">len</span>(uniq))</div><div class="line">   name := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(uniq))</div><div class="line">   <span class="keyword">for</span> key, _ := <span class="keyword">range</span> uniq &#123;</div><div class="line">      name = <span class="built_in">append</span>(name, key)</div><div class="line">   &#125;</div><div class="line">   answer += <span class="string">" "</span></div><div class="line">   sort.Strings(name)</div><div class="line">   answer += strings.Join(name, <span class="string">","</span>)</div><div class="line">   <span class="keyword">return</span> answer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MapReduce是Google公司的Jeffrey和Sanjay提出的一个编程模型，主要用于大规模数据集的并行运算。它吸收了函数式编程语言中的Map和Reduce，通过Map处理原始键值对生成中间键值对，通过Reduce合并相同中间键对应的值。这一特性符合很多现实生活中的场景。&lt;/p&gt;
&lt;p&gt;这种编程模型下的程序可以并行化地在大规模集群上运行，而在这一过程中用户却不需考虑输入数据的划分、程序的运行安排、节点故障和机器间通信，只需完成对数据的处理和合并。&lt;/p&gt;
&lt;p&gt;我阅读了MapReduce的论文，并完成了MIT 6.824的第一个Lab，对其有了更深的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://qzwlecr.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Lab" scheme="http://qzwlecr.github.io/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode一句话题解</title>
    <link href="http://qzwlecr.github.io/2017/05/20/Leetcode%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/"/>
    <id>http://qzwlecr.github.io/2017/05/20/Leetcode一句话题解/</id>
    <published>2017-05-20T05:48:57.000Z</published>
    <updated>2017-07-17T06:49:45.834Z</updated>
    
    <content type="html"><![CDATA[<p>最近无聊，刷了一批Leetcode水题，用简要题解记录一下做题过程，也小小帮助一下被坑所困的人。</p>
<a id="more"></a>
<h2 id="1-10"><a href="#1-10" class="headerlink" title="1~10"></a>1~10</h2><ol>
<li><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="external">Two Sum</a></p>
<ol>
<li>$O(n^2)$：暴力枚举</li>
<li>$O(nlogn)$：排序+two-pointers或者map/set大法好</li>
<li>$O(n)$：哈希表</li>
</ol>
</li>
<li><p><a href="https://leetcode.com/problems/add-two-numbers" target="_blank" rel="external">Add Two Numbers</a></p>
<p>$O(n)$，边处理边进位，注意最后一位进位和链表为空的边界情况</p>
</li>
<li><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="external">Longest Substring Without Repeating Characters</a></p>
<ol>
<li>$O(nlogn)$，滑动窗口，用一个set维护当前的字符集，如果新加入的字符以前出现过，抛弃左边重复的字符，所有字符有且仅有被遍历一遍</li>
<li>$O(n)$，把set换为哈希表</li>
</ol>
</li>
<li><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays" target="_blank" rel="external">Median of Two Sorted Arrays</a></p>
<p>$O(log(min(m,n))$，特判数组大小为(0,*)(1,*)(2,*)的情况，二分查找，注意奇怪的边界情况</p>
</li>
<li><p><a href="https://leetcode.com/problems/longest-palindromic-substring" target="_blank" rel="external">Longest Palindromic Substring</a></p>
<p>$O(n)$，强上manacher算法</p>
</li>
<li><p><a href="https://leetcode.com/problems/zigzag-conversion" target="_blank" rel="external">ZigZag Conversion</a></p>
<p>手动模拟一下“ZIGZAG”的样子，模拟过程</p>
</li>
<li><p><a href="https://leetcode.com/problems/reverse-integer" target="_blank" rel="external">Reverse Integer</a></p>
<p>按位取出，重新分配，注意溢出问题</p>
</li>
<li><p><a href="https://leetcode.com/problems/string-to-integer-atoi" target="_blank" rel="external">String to Integer (atoi)</a></p>
<p>按位取出，重新分配，注意符号和溢出问题</p>
</li>
<li><p><a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="external">Palindrome Number</a></p>
<p>$O(n)$，从两边向中间判断</p>
</li>
<li><p><a href="https://leetcode.com/problems/regular-expression-matching" target="_blank" rel="external">Regular Expression Matching</a></p>
<p>$O(mn)$，DP，按下一个是否为’*’分类讨论</p>
</li>
</ol>
<h2 id="11-20"><a href="#11-20" class="headerlink" title="11~20"></a>11~20</h2><ol>
<li><p><a href="https://leetcode.com/problems/container-with-most-water" target="_blank" rel="external">Container With Most Water</a></p>
<p>$O(n)$，two pointers，移动高度较小的指针，使结果尽量大。</p>
</li>
<li><p><a href="https://leetcode.com/problems/integer-to-roman" target="_blank" rel="external">Integer to Roman</a></p>
<p>模拟题，按照罗马数字的规则追加相应的字符串。</p>
</li>
<li><p><a href="https://leetcode.com/problems/roman-to-integer" target="_blank" rel="external">Roman to Integer</a></p>
<p>模拟题，按照罗马数字的规则加上相应的数字。</p>
</li>
<li><p><a href="https://leetcode.com/problems/longest-common-prefix" target="_blank" rel="external">Longest Common Prefix</a></p>
<p>模拟题，按照长度排序，然后搜索最短的字符串最大能匹配到所有的字符串的第多少个字符。</p>
</li>
<li><p><a href="https://leetcode.com/problems/3sum" target="_blank" rel="external">3Sum</a></p>
<p>$O(n^2)$，two pointers，枚举一个数，然后在后面的序列寻找满足的两个数，注意去重。</p>
</li>
<li><p><a href="https://leetcode.com/problems/3sum-closest" target="_blank" rel="external">3Sum Closest</a></p>
<p>与3Sum相同， 只是记录的时候判断并记录距离最小的值。</p>
</li>
<li><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number" target="_blank" rel="external">Letter Combinations of a Phone Number</a></p>
<p>模拟题，每次循环往上次生成的序列中的每个元素尾部追加相应字符。</p>
</li>
<li><p><a href="https://leetcode.com/problems/4sum" target="_blank" rel="external">4Sum</a></p>
<p>与3Sum相同，只是需要枚举两个值。</p>
</li>
<li><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank" rel="external">Remove Nth Node From End of List</a></p>
<p>简单的链表操作，注意删除首节点的情况。</p>
</li>
<li><p><a href="https://leetcode.com/problems/valid-parentheses" target="_blank" rel="external">Valid Parentheses</a></p>
<p>使用一个栈维护一下之前的左括号，按照右括号判断，若无对应的左括号则无法匹配。</p>
</li>
</ol>
<h2 id="21-30"><a href="#21-30" class="headerlink" title="21-30"></a>21-30</h2><p>to be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近无聊，刷了一批Leetcode水题，用简要题解记录一下做题过程，也小小帮助一下被坑所困的人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://qzwlecr.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://qzwlecr.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>NFC与门禁卡初探</title>
    <link href="http://qzwlecr.github.io/2017/05/17/NFC%E4%B8%8E%E9%97%A8%E7%A6%81%E5%8D%A1%E5%88%9D%E6%8E%A2/"/>
    <id>http://qzwlecr.github.io/2017/05/17/NFC与门禁卡初探/</id>
    <published>2017-05-17T03:36:21.000Z</published>
    <updated>2017-07-17T07:11:05.020Z</updated>
    
    <content type="html"><![CDATA[<p>开学之后，学校寝室和启明学院都开始使用了以校园卡为载体的门禁服务，只有刷指定人员的校园卡才能进入。我对其原理产生了好奇，就趁机进行了一些研究。</p>
<a id="more"></a>
<h1 id="了解NFC"><a href="#了解NFC" class="headerlink" title="了解NFC"></a>了解NFC</h1><p>NFC，near field communication(近场通信)，是一种短距离的高频无线通信技术，允许电子设备之间进行非接触式点对点数据传输，在十厘米内交换数据。2004年，诺基亚、飞利浦以及索尼三家公司建立了NFC forum，成为了NFC的开端。</p>
<p>NFC从其本质上来说，是一种RFID的演进技术，其于04年和05年发布了两个协议标准，分别是ISO/IEC 18092：2004和ISO/IEC 21481：2005。上述两个协议均源于更早的RFID协议 ISO/IEC 14443，即13.56MHz RFID协议标准。上述两个NFC协议推出的第二版分别是ISO/IEC 18092：2013(NFCIP-1)和ISO/IEC 21481：2012(NFCIP-2)。NFC向下兼容索尼的FeliCaTM标准以及飞利浦的MIFARE标准。</p>
<table>
<thead>
<tr>
<th>技术</th>
<th>协议</th>
<th>频率</th>
<th>传输距离</th>
<th>主动</th>
<th>被动</th>
<th>典型设备和应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>NFC</td>
<td>ISO/IEC 18092<br>ISO/IEC 21481</td>
<td>13.56 MHz</td>
<td>10 cm</td>
<td>√</td>
<td>√</td>
<td>对等网络中的智能手机、平板电脑、便携式设备</td>
</tr>
<tr>
<td>免接触智能卡</td>
<td>ISO/IEC 14443</td>
<td>13.56 MHz</td>
<td>10 cm</td>
<td></td>
<td>√</td>
<td>票务、支付、门禁、护照等</td>
</tr>
<tr>
<td>RFID</td>
<td>ISO/IEC 18000</td>
<td>LF (120–150 KHz)<br>HF (13.56 MHz)<br>UHF (433–900 MHz)</td>
<td>&lt;40 m</td>
<td>√</td>
<td>√</td>
<td>标记和跟踪物品，适用于制造物流、零售等</td>
</tr>
</tbody>
</table>
<p>NFC的工作模式有三种，卡模拟模式（Card emulation mode）、点对点模式（P2P mode）和读/写模式（Reader/Writer mode）。</p>
<ul>
<li>在读/写模式中，NFC读/写器从NFC智能对象中读取数据，并根据这些信息操作。例如，采用支持NFC的手机，用户可以通过检索的URL自动联网、无需键入便可发送短信(SMS)文本、获取优惠券等，所有这些仅需触摸此对象的设备即可。</li>
<li>在点对点模式中，任何支持NFC功能的读/写器都可与另一个NFC读/写器进行通信并交换数据，与读/写模式具有同样的安全性、直观性和简单性等优势。在这种模式下，一个读/写器可作为一个标签，创建通信链路。例如，具有读/写器的两个设备(如智能电话)可以彼此通信。</li>
<li>卡模拟模式的NFC器件可以取代非接触式智能卡，使NFC器件能够用于现有的非接触式卡基础设施，进行票务、门禁、运输、收费站以及非接触式支付等操作。</li>
</ul>
<h1 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h1><h2 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h2><p>由于采集门禁卡信息时，只需要提供学号和姓名，以及卡编号，无需其他信息，故推测门禁只是简单读取卡的ID，而不会去解密其他信息，只需要使用卡模拟模式，简单地模拟一个ID相同的卡即可。在网上查阅资料可得知，门禁卡的工作原理大多如此。</p>
<h2 id="信息采集"><a href="#信息采集" class="headerlink" title="信息采集"></a>信息采集</h2><p>由于手头设备有限，只能用手机查看校园卡的ID信息。</p>
<p><a href="https://play.google.com/store/apps/details?id=com.wakdev.wdnfc" target="_blank" rel="external">NFC Tools下载地址</a><br><img src="/images/NFC-card/ID-information.jpg" alt=""></p>
<p>容易得到，Serial number处为形如<code>XX:XX:XX:XX</code>的ID（X为16进制数字）。这就是门禁所识别的ID。</p>
<h2 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h2><p>查阅相关资料可以得知，NFC的相应配置保存在<code>/system/etc/libnfc-nxp.conf</code>或<code>/system/etc/libnfc-brcm.conf</code>中，具体的配置取决于NFC芯片的类型。</p>
<p>手头有一部Nexus 6P，其芯片为NXP PN548，故阅读了<code>libnfc-nxp.conf</code>，通过注释从中发现了需要更改的配置。在文件的607行，有Core configuration settings中的<code>LA_NFCID1</code>，代表了手机NFC的NFCA-ID，这正是门禁系统能识别的ID。这里，33表示配置的类型，04表示后面所跟的配置字节数，后面的四个字节为数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">###############################################################################</div><div class="line"># Core configuration settings</div><div class="line"># It includes</div><div class="line"># 18        - Poll Mode NFC-F:   PF_BIT_RATE</div><div class="line"># 21        - Poll Mode ISO-DEP: PI_BIT_RATE</div><div class="line"># 28        - Poll Mode NFC-DEP: PN_NFC_DEP_SPEED</div><div class="line"># 30        - Lis. Mode NFC-A:   LA_BIT_FRAME_SDD</div><div class="line"># 31        - Lis. Mode NFC-A:   LA_PLATFORM_CONFIG</div><div class="line"># 33        - Lis. Mode NFC-A:   LA_NFCID1</div><div class="line"># 50        - Lis. Mode NFC-F:   LF_PROTOCOL_TYPE</div><div class="line"># 54        - Lis. Mode NFC-F:   LF_CON_BITR_F</div><div class="line"># 5B        - Lis. Mode ISO-DEP: LI_BIT_RATE</div><div class="line"># 60        - Lis. Mode NFC-DEP: LN_WT</div><div class="line"># 80        - Other Param.:      RF_FIELD_INFO</div><div class="line"># 81        - Other Param.:      RF_NFCEE_ACTION</div><div class="line"># 82        - Other Param.:      NFCDEP_OP</div><div class="line">NXP_CORE_CONF=&#123;20, 02, 2B, 0D,</div><div class="line">        18, 01, 01,</div><div class="line">        21, 01, 00,</div><div class="line">        28, 01, 00,</div><div class="line">        30, 01, 08,</div><div class="line">        31, 01, 03,</div><div class="line">        33, 04, 00, 00, 00, 00,</div><div class="line">        50, 01, 02,</div><div class="line">        54, 01, 06,</div><div class="line">        5B, 01, 00,</div><div class="line">        60, 01, 0E,</div><div class="line">        80, 01, 01,</div><div class="line">        81, 01, 01,</div><div class="line">        82, 01, 0E</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="信息修改"><a href="#信息修改" class="headerlink" title="信息修改"></a>信息修改</h2><p>将上面获取到的ID插入配置文件中，重启手机NFC，即可完成修改。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/system/bin/sh</span></div><div class="line">sed -i <span class="string">'607s/^.*$/        33, 04, XX, XX, XX, XX,/'</span> /etc/libnfc-nxp.conf</div></pre></td></tr></table></figure>
<h2 id="批量修改"><a href="#批量修改" class="headerlink" title="批量修改"></a>批量修改</h2><p>尝试着写了批量修改的脚本，以完成某些特殊要求，但是由于安卓系统本身的限制，无法做到自动重启NFC，贴代码仅供参考。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/system/bin/sh</span></div><div class="line">setenforce 0</div><div class="line"><span class="built_in">echo</span> <span class="string">"SElinux disabled"</span></div><div class="line"><span class="comment">#disable SElinux</span></div><div class="line">mount -o rw,remount /system</div><div class="line"><span class="built_in">echo</span> <span class="string">"nfc disabled"</span></div><div class="line">service call nfc 5</div><div class="line">sleep 1</div><div class="line"><span class="comment">#first person</span></div><div class="line">sed -i <span class="string">'607s/^.*$/        33, 04, XX, XX, XX, XX,/'</span> /etc/libnfc-nxp.conf</div><div class="line">sleep 1</div><div class="line">service call nfc 6</div><div class="line"><span class="built_in">echo</span> <span class="string">"nfc enabled"</span></div><div class="line">sleep 5</div><div class="line">service call nfc 5</div><div class="line"><span class="built_in">echo</span> <span class="string">"nfc disabled"</span></div><div class="line">sleep 1</div><div class="line"><span class="comment">#second person</span></div><div class="line">sed -i <span class="string">'607s/^.*$/        33, 04, XX, XX, XX, XX,/'</span> /etc/libnfc-nxp.conf</div><div class="line">service call nfc 6</div><div class="line"><span class="built_in">echo</span> <span class="string">"nfc enabled"</span></div><div class="line">sleep 1</div><div class="line">setenforce 1</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>门禁使用易于复制的射频卡ID检测是极为不安全的，外来人员只需要注意到这一点就可以轻松地进入宿舍，同时，此功能还可以用来体育打卡、进入图书馆等，需要慎加利用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开学之后，学校寝室和启明学院都开始使用了以校园卡为载体的门禁服务，只有刷指定人员的校园卡才能进入。我对其原理产生了好奇，就趁机进行了一些研究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NFC" scheme="http://qzwlecr.github.io/tags/NFC/"/>
    
      <category term="hack" scheme="http://qzwlecr.github.io/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>HelloWorld</title>
    <link href="http://qzwlecr.github.io/2017/02/27/HelloWorld/"/>
    <id>http://qzwlecr.github.io/2017/02/27/HelloWorld/</id>
    <published>2017-02-27T13:51:58.000Z</published>
    <updated>2017-07-17T06:19:20.927Z</updated>
    
    <content type="html"><![CDATA[<p>啊小红红真可爱。<br>说完啦。<br>hello,world!!!!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;啊小红红真可爱。&lt;br&gt;说完啦。&lt;br&gt;hello,world!!!!&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
